"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const fs_extra_1 = require("fs-extra");
const path_1 = require("path");
const utils_1 = require("../../utils");
function validateConfig(config) {
    const info = utils_1.getWorkspaceInfo({ cwd: config.cwd });
    const { isPrerelease } = utils_1.parseVersion(config.version);
    const validated = Object.assign(Object.assign({}, config), { nx: info.nx, npmScope: `@${info.nx.npmScope}`, npmTag: isPrerelease ? 'next' : 'latest', package: info.package, preRelease: isPrerelease, workspacePath: info.path, workspaceType: info.type, workspace: info.workspace });
    if (!validated.version) {
        utils_1.log(utils_1.red('ERROR'), 'Please provide the release version (like: 1.2.3-beta.4)');
        return false;
    }
    if (!utils_1.parseVersion(config.version).isValid) {
        utils_1.log(utils_1.red('ERROR'), 'Please provide a valid release version (like: 1.2.3-beta.4)');
        return false;
    }
    utils_1.log(`VALIDATE`, `Using ${utils_1.yellowBright(validated.workspaceType)} workspace: ${utils_1.gray(path_1.relative(config.cwd, validated.workspacePath))}`);
    return validated;
}
exports.validateConfig = validateConfig;
function validateWorkspace(config) {
    const { projects } = config.workspace;
    const libs = Object.keys(projects)
        .map((id) => (Object.assign({ id }, projects[id])))
        .filter((project) => project.projectType === 'library');
    if (!libs.length) {
        throw new Error(`No libraries found in nx workspace ${config.workspacePath}`);
    }
    utils_1.log(`VALIDATE`, `Found ${utils_1.yellowBright(libs.length)} libraries:`);
    // Find libraries that have a package builder
    const packages = libs
        .map((lib) => ({
        lib,
        architect: Object.keys(lib.architect)
            .map((id) => (Object.assign({ id }, lib.architect[id])))
            // We only include architects that are called 'build'
            .filter((architect) => architect.id === 'build')
            .find(({ builder }) => utils_1.NX_PACKAGE_BUILDERS.includes(builder)),
    }))
        // Only release packages which turned out to have at least one 'publishable' architect
        .filter((lib) => !!lib.architect);
    for (const pkg of packages) {
        utils_1.log(`VALIDATE`, `Found builder for ${utils_1.yellowBright(pkg.lib.id)}: ${utils_1.gray(pkg.architect.builder)} `);
    }
    return {
        packages,
    };
}
exports.validateWorkspace = validateWorkspace;
function validatePackages(config, workspace) {
    // Validate libraries before packaging
    const invalid = workspace.packages.filter(({ lib }) => {
        const name = `${config.npmScope}/${lib.id}`;
        return !utils_1.validatePackageJson(lib.root, {
            dryRun: config.dryRun,
            fix: config.fix,
            version: config.version,
            name,
            workspacePkgJson: config.package,
        });
    });
    if (invalid.length) {
        const invalidIds = invalid.map((item) => item.lib.id);
        utils_1.log(utils_1.red(`Could not continue because of errors in the following packages:`));
        console.log(invalidIds);
        if (!config.fix) {
            utils_1.log('Try running this command with the --fix flag to fix some common problems');
        }
        return false;
    }
    const pkgFiles = workspace.packages
        .map((pkg) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        if (!((_b = (_a = pkg.architect) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.outputPath) && !((_d = (_c = pkg.architect) === null || _c === void 0 ? void 0 : _c.options) === null || _d === void 0 ? void 0 : _d.project)) {
            console.log('pkg.architect?.options', (_e = pkg.architect) === null || _e === void 0 ? void 0 : _e.options);
            throw new Error(`Error determining dist path for ${pkg.lib.id}`);
        }
        if ((_g = (_f = pkg.architect) === null || _f === void 0 ? void 0 : _f.options) === null || _g === void 0 ? void 0 : _g.outputPath) {
            // @nrwl/node:package builder
            return (_j = (_h = pkg.architect) === null || _h === void 0 ? void 0 : _h.options) === null || _j === void 0 ? void 0 : _j.outputPath;
        }
        if ((_l = (_k = pkg === null || pkg === void 0 ? void 0 : pkg.architect) === null || _k === void 0 ? void 0 : _k.options) === null || _l === void 0 ? void 0 : _l.project) {
            // @nrwl/angular:package builder
            const ngPackagePath = path_1.join(config.cwd, (_o = (_m = pkg === null || pkg === void 0 ? void 0 : pkg.architect) === null || _m === void 0 ? void 0 : _m.options) === null || _o === void 0 ? void 0 : _o.project);
            const ngPackageJson = fs_extra_1.readJSONSync(ngPackagePath);
            return path_1.relative(config.cwd, path_1.resolve(pkg.lib.root, ngPackageJson.dest));
        }
        throw new Error(`Can't find pkg file`);
    })
        .map((file) => path_1.join(file, 'package.json'));
    if (config.build) {
        utils_1.exec(`yarn nx run-many --target build --all`);
    }
    // Here we check of the expected packages are built
    const foundPkgFiles = pkgFiles.map((pkgFile) => {
        var _a, _b;
        const pkgPath = path_1.join(config.cwd, pkgFile);
        const exists = fs_1.existsSync(pkgPath);
        if (!exists) {
            utils_1.error(`Could not find ${pkgFile}. Make sure to build your packages before releasing`);
            return false;
        }
        const pkgJson = fs_extra_1.readJSONSync(pkgPath);
        fs_1.writeFileSync(pkgPath, JSON.stringify(Object.assign(Object.assign({}, pkgJson), { version: config.version }), null, 2));
        if (((_a = pkgJson.scripts) === null || _a === void 0 ? void 0 : _a.prepublishOnly) && ((_b = pkgJson.scripts) === null || _b === void 0 ? void 0 : _b.prepublishOnly.includes(
        // Don't patronize me... Seriously, screw this shit...
        'ERROR: Trying to publish a package that has been compiled by Ivy. This is not allowed.')) &&
            config.allowIvy) {
            fs_1.writeFileSync(pkgPath, JSON.stringify(Object.assign(Object.assign({}, pkgJson), { scripts: Object.assign(Object.assign({}, pkgJson.scripts), { prepublishOnly: 'true' }) }), null, 2));
            utils_1.log(`VALIDATE`, `Allow publishing Ivy package ðŸ˜˜ ${pkgJson.name}`);
        }
        return pkgFile;
    });
    if (foundPkgFiles.length !== pkgFiles.length) {
        return false;
    }
    utils_1.log('VALIDATE', `Found ${foundPkgFiles.length} packages to release`);
    return {
        pkgFiles,
    };
}
exports.validatePackages = validatePackages;
