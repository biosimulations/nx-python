"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const inquirer = require("inquirer");
const utils_1 = require("../../utils");
const projects_1 = require("../projects/projects");
const sandbox_utils_1 = require("./utils/sandbox-utils");
exports.selectSandbox = async (sandboxes, message) => {
    const sandboxName = await utils_1.selectFromList(sandboxes, { message, addExit: true });
    if (!sandboxName) {
        return false;
    }
    return { sandboxName };
};
exports.getConfigAction = (config) => {
    switch (config.action) {
        case 'run':
            return projects_1.RUN_OPTION;
    }
};
exports.selectSandboxFlow = async (config, sandboxName) => {
    var _a;
    const [sandboxes, images] = await Promise.all([sandbox_utils_1.getSandboxUrlCache(config), sandbox_utils_1.getDockerImages()]);
    if (config.sandboxId) {
        sandboxName = (_a = sandboxes.find((sandbox) => sandbox.id === config.sandboxId)) === null || _a === void 0 ? void 0 : _a.name;
    }
    const availableSandboxes = sandboxes
        .map((s) => s.name)
        .filter((name) => !images.includes(name));
    const installedSandboxes = sandboxes
        .map((s) => s.name)
        .filter((name) => images.includes(name));
    const options = [];
    if (!sandboxName) {
        console.clear();
        if (installedSandboxes.length !== 0) {
            options.push(new inquirer.Separator('Installed Sandboxes'), ...installedSandboxes.sort());
        }
        if (availableSandboxes.length !== 0) {
            options.push(new inquirer.Separator('Available Sandboxes'), ...availableSandboxes.sort());
        }
        const sandboxResult = await exports.selectSandbox(options, 'Sandboxes');
        if (!sandboxResult) {
            return Promise.resolve(false);
        }
        sandboxName = sandboxResult.sandboxName;
    }
    const sandbox = sandboxes.find((p) => p.name === sandboxName);
    if (!sandbox) {
        utils_1.error(`Plugin ${sandboxName} not found`);
        return Promise.resolve(false);
    }
    // eslint-disable-next-line no-console
    console.log(`
  ${sandbox.description}
  ${utils_1.gray(sandbox.url)}
`);
    const isInstalled = installedSandboxes.includes(sandboxName);
    const availableOptions = [projects_1.INSTALL_OPTION];
    const installedOptions = [projects_1.RUN_OPTION, projects_1.REMOVE_OPTION];
    const selection = config.action
        ? exports.getConfigAction(config)
        : await utils_1.selectFromList(isInstalled ? installedOptions : availableOptions, {
            addBack: true,
            addExit: true,
            message: sandboxName,
        });
    if (!selection) {
        return Promise.resolve(false);
    }
    return {
        selection,
        sandboxName,
        sandbox,
    };
};
const loop = async (config, { sandboxName }) => {
    const result = await exports.selectSandboxFlow(config, sandboxName);
    if (!result) {
        return;
    }
    if (result.selection === projects_1.INSTALL_OPTION) {
        utils_1.log('INSTALL', result.sandboxName);
        await sandbox_utils_1.pullDockerImage(result.sandboxName);
        console.clear();
        await loop(config, { sandboxName: result.sandboxName });
    }
    if (result.selection === projects_1.REMOVE_OPTION) {
        utils_1.log('REMOVE', result.sandboxName);
        try {
            await sandbox_utils_1.removeDockerImage(result.sandboxName, false);
        }
        catch (e) {
            utils_1.error(e.message);
            const res = await inquirer.prompt([
                {
                    name: 'force',
                    type: 'confirm',
                    message: 'Do you want to force removal?',
                    default: false,
                },
            ]);
            if (res.force) {
                await sandbox_utils_1.removeDockerImage(result.sandboxName, true);
            }
        }
        await loop(config, { sandboxName: undefined });
    }
    if (result.selection === projects_1.RUN_OPTION && result.sandbox) {
        utils_1.log('RUN', `${result.sandbox.id} ${utils_1.gray(result.sandboxName)}`);
        try {
            const ports = [];
            if (config.portApi) {
                ports.push(config.portApi);
            }
            if (config.portWeb) {
                ports.push(config.portWeb);
            }
            if (config.ports) {
                ports.push(...(config.ports.includes(',') ? config.ports.split(',') : [config.ports]));
            }
            await sandbox_utils_1.runDockerImage(result.sandboxName, {
                options: {
                    hostname: result.sandbox.id,
                    name: result.sandbox.id,
                    params: [],
                    ports,
                },
            });
        }
        catch (e) {
            utils_1.error(e.message);
        }
        // await loop(config, { sandboxName: result.sandboxName })
    }
    if (result.selection.startsWith(result.sandboxName)) {
        utils_1.log('Running sandbox', result.selection);
        // const command = `${info.cli} generate ${result.selection}`
        // exec(command)
        utils_1.log('Done');
    }
    if (result.selection === projects_1.BACK_OPTION) {
        await loop(config, {});
    }
};
exports.sandbox = async (config) => {
    await sandbox_utils_1.sandboxUrlCache(config);
    await loop(config, {});
};
