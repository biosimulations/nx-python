"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = require("fs-extra");
const inquirer = require("inquirer");
const lodash_1 = require("lodash");
const path_1 = require("path");
const utils_1 = require("../../utils");
exports.BACK_OPTION = '[ BACK ]';
exports.EXIT_OPTION = '[ EXIT ]';
exports.INSTALL_OPTION = '[ INSTALL ]';
exports.REMOVE_OPTION = '[ REMOVE ]';
exports.RUN_OPTION = '[ RUN ]';
exports.setType = (type) => {
    switch (type) {
        case 'boolean':
            return 'confirm';
        default:
            return 'input';
    }
};
exports.getSchematicParams = (cwd, param) => {
    try {
        const [pkg, schematic] = param.split(':');
        const pkgRootPath = path_1.join(cwd, 'node_modules', pkg);
        // Get schematics property form {cwd}/node_modules/{pkg}/package.json
        const pkgJsonPath = path_1.join(pkgRootPath, 'package.json');
        const pkgJson = fs_extra_1.readJSONSync(pkgJsonPath);
        if (!pkgJson) {
            return Promise.reject(new Error(`Package ${pkg} not found`));
        }
        if (!pkgJson.schematics) {
            return Promise.reject(new Error(`Package ${pkg} does not have schematics`));
        }
        // Get collection.json defined in schematics
        const collectionPath = path_1.join(pkgRootPath, pkgJson.schematics);
        const collection = fs_extra_1.readJSONSync(collectionPath);
        if (!collection || !collection.schematics) {
            return Promise.reject(new Error(`Collections for ${pkg} not found`));
        }
        if (!collection.schematics[schematic]) {
            return Promise.reject(new Error(`Collection in ${pkg} does not have schematic ${schematic}`));
        }
        // Get schema.json from selected schematic
        const schematicDef = collection.schematics[schematic];
        if (!schematicDef.schema) {
            return Promise.resolve({});
        }
        const schemaPath = path_1.join(pkgRootPath, schematicDef.schema);
        const schema = fs_extra_1.readJSONSync(schemaPath);
        if (!schema || !schema.properties) {
            return Promise.reject(new Error(`Properties for ${pkg}:${schematic} not found`));
        }
        const schemaProperties = schema.properties;
        const properties = [
            ...Object.keys(schemaProperties).map((property) => {
                var _a, _b;
                return ({
                    name: property,
                    type: exports.setType(schemaProperties[property].type),
                    message: (_a = schemaProperties[property]) === null || _a === void 0 ? void 0 : _a.description,
                    default: (_b = schemaProperties[property]) === null || _b === void 0 ? void 0 : _b.default,
                });
            }),
            {
                name: 'dryRun',
                type: 'confirm',
                message: 'Do you want to do a dry-run?',
                default: false,
            },
        ];
        return Promise.resolve({ properties });
    }
    catch (error) {
        error(error);
        return Promise.reject(error);
    }
};
const selectProjectName = async (info) => {
    var _a;
    const items = ((_a = info.workspace) === null || _a === void 0 ? void 0 : _a.projects) || [];
    if (Object.keys(items).length === 0) {
        utils_1.error("Can't find any projects in this workspace");
        return Promise.resolve(false);
    }
    const projectList = Object.keys(items).map((item) => ({
        projectName: item,
        type: items[item].projectType,
    }));
    const apps = projectList
        .filter((t) => t.type === 'application')
        .map((t) => t.projectName)
        .sort();
    const libs = projectList
        .filter((t) => t.type === 'library')
        .map((t) => t.projectName)
        .sort();
    const options = [];
    if (apps.length !== 0) {
        options.push(new inquirer.Separator('Apps'), ...apps);
    }
    if (libs.length !== 0) {
        options.push(new inquirer.Separator('Libraries:'), ...libs);
    }
    const projectName = await utils_1.selectFromList(options, {
        addExit: true,
        message: `Select project (${projectList.length} found)`,
    });
    if (projectName === false) {
        return Promise.resolve(false);
    }
    return projectName;
};
const selectProjectAction = async (info, { target, params, projectName, project, }) => {
    const answers = { projectName };
    const architects = Object.keys(project === null || project === void 0 ? void 0 : project.architect).sort();
    const schematics = ['@nrwl/workspace:move', '@nrwl/workspace:remove'];
    const projectOptions = [
        new inquirer.Separator('Builders'),
        ...architects,
        new inquirer.Separator('Schematics'),
        ...schematics,
    ];
    if (!target) {
        const found = await utils_1.selectFromList(projectOptions, {
            addExit: true,
            message: `Selected ${project.projectType} ${projectName} ${utils_1.gray(project.root)}`,
        });
        if (!found) {
            utils_1.error(`Action not found`);
            return Promise.resolve(false);
        }
        target = found;
    }
    if (architects.includes(target)) {
        const architectParams = lodash_1.get(params, `${target}.params`, '');
        return {
            action: 'exec',
            payload: `${info.cli} run ${projectName}:${target} ${architectParams}`,
        };
    }
    if (schematics.includes(target)) {
        const params = await exports.getSchematicParams(info.cwd, target);
        const payload = [`${info.cli} generate ${target}`];
        if (Object.keys(params.properties).length !== 0) {
            Object.keys(answers).forEach((answer) => payload.push(` --${answer} ${answers[answer]}`));
            const res = await inquirer.prompt(params.properties.filter((p) => {
                return !Object.keys(answers).includes(p.name);
            }));
            Object.keys(res).forEach((answer) => payload.push(` --${answer} ${res[answer]}`));
        }
        return { action: 'exec', payload: payload.join(' ') };
    }
    return Promise.resolve(false);
};
exports.interactive = async (info, config, { projectName, target }) => {
    var _a;
    if (!projectName) {
        const res = await selectProjectName(info);
        if (res) {
            projectName = res;
        }
    }
    if (typeof projectName === 'undefined') {
        return;
    }
    const project = (_a = info === null || info === void 0 ? void 0 : info.workspace) === null || _a === void 0 ? void 0 : _a.projects[projectName];
    if (!project) {
        utils_1.error(`Project ${projectName} not found`);
        return;
    }
    const params = lodash_1.get(config === null || config === void 0 ? void 0 : config.userConfig, 'projects', {});
    const projectActionResult = await selectProjectAction(info, {
        target,
        projectName,
        project,
        params,
    });
    if (projectActionResult === false) {
        return;
    }
    if (projectActionResult.action === 'exec') {
        utils_1.exec(`${projectActionResult.payload}`);
        utils_1.exec(`yarn format`, { stdio: 'ignore' });
    }
    else {
        utils_1.error(`Unknown action ${projectActionResult.action}`);
    }
};
exports.projects = async (config, projectName, target) => {
    utils_1.log('Projects', utils_1.gray(`Working directory ${config.cwd}`));
    const info = utils_1.getWorkspaceInfo({ cwd: config.cwd });
    await exports.interactive(info, config, { projectName, target });
};
