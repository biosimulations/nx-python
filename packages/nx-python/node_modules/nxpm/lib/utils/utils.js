"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const fs_extra_1 = require("fs-extra");
const inquirer = require("inquirer");
const node_fetch_1 = require("node-fetch");
const path_1 = require("path");
const releaseIt = require("release-it");
const projects_1 = require("../lib/projects/projects");
const logging_1 = require("./logging");
exports.exec = (command, options) => child_process_1.execSync(command, Object.assign({ stdio: [0, 1, 2] }, options));
exports.run = (command) => {
    logging_1.log('RUNNING', command);
    exports.exec(command);
};
exports.getPackageJson = (root) => {
    const pkgPath = path_1.join(process.cwd(), root, 'package.json');
    if (!fs_1.existsSync(pkgPath)) {
        logging_1.log(logging_1.red(`Could not find package.json in ${root}`));
        return null;
    }
    return fs_extra_1.readJSONSync(pkgPath);
};
exports.updatePackageJson = (root, obj) => {
    const pkgPath = path_1.join(process.cwd(), root, 'package.json');
    const pkgJson = exports.getPackageJson(root);
    fs_extra_1.writeFileSync(pkgPath, JSON.stringify(Object.assign(Object.assign({}, pkgJson), obj), null, 2) + '\n');
    return exports.getPackageJson(root);
};
exports.validatePackageJsonLicense = (root, { pkgJson, license }) => {
    // Verify that the name in package.json is correct
    if (!pkgJson.license) {
        logging_1.log(logging_1.red('ERROR'), `License not defined in in ${path_1.join(root, 'package.json')}`);
        return false;
    }
    if (pkgJson.license !== license) {
        logging_1.log(logging_1.red('ERROR'), `License not valid in ${path_1.join(root, 'package.json')}, should be "${license}", not "${pkgJson.license}"`);
        return false;
    }
    return true;
};
exports.validatePackageJsonName = (root, { pkgJson, name }) => {
    var _a;
    if ((_a = pkgJson === null || pkgJson === void 0 ? void 0 : pkgJson.nxpm) === null || _a === void 0 ? void 0 : _a.allowPackageName) {
        return true;
    }
    // Verify that the name in package.json is correct
    if (pkgJson.name !== name) {
        logging_1.log(logging_1.red('ERROR'), `Name not valid in ${path_1.join(root, 'package.json')}, should be "${name}", not "${pkgJson.name}"  `);
        return false;
    }
    return true;
};
exports.validatePackageJsonVersion = (root, { pkgJson, version }) => {
    // Verify that the version is set correctly
    if (!pkgJson.version || pkgJson.version !== version) {
        logging_1.log(logging_1.red('ERROR'), `Version "${pkgJson.version}" should be "${version}" in ${path_1.join(root, 'package.json')} `);
        return false;
    }
    return true;
};
exports.updatePackageJsonLicense = (root, { license }) => {
    exports.updatePackageJson(root, { license });
    logging_1.log(logging_1.greenBright('FIXED'), `License set to ${license} in ${path_1.join(root, 'package.json')}`);
    return exports.validatePackageJsonLicense(root, { pkgJson: exports.getPackageJson(root), license });
};
exports.updatePackageJsonVersion = (root, { version }) => {
    exports.updatePackageJson(root, { version });
    logging_1.log(logging_1.greenBright('FIXED'), `Version set to "${version}" in ${path_1.join(root, 'package.json')}`);
    return exports.validatePackageJsonVersion(root, { pkgJson: exports.getPackageJson(root), version });
};
exports.updatePackageJsonName = (root, { name }) => {
    exports.updatePackageJson(root, { name });
    logging_1.log(logging_1.greenBright('FIXED'), `Name set to "${name}" in ${path_1.join(root, 'package.json')}`);
    return exports.validatePackageJsonName(root, { pkgJson: exports.getPackageJson(root), name });
};
exports.validatePackageJson = (root, { dryRun = false, fix, name, version, workspacePkgJson, }) => {
    // Read the libs package.json
    const pkgJson = exports.getPackageJson(root);
    if (!pkgJson) {
        return false;
    }
    let hasErrors = false;
    // Verify that the version is set correctly
    if (!exports.validatePackageJsonVersion(root, { pkgJson, version })) {
        if (fix) {
            hasErrors = !exports.updatePackageJsonVersion(root, { version });
        }
        else {
            hasErrors = true;
        }
    }
    // Verify License
    if (!exports.validatePackageJsonLicense(root, { pkgJson, license: workspacePkgJson.license })) {
        if (fix) {
            hasErrors = !exports.updatePackageJsonLicense(root, { license: workspacePkgJson.license });
        }
        else {
            hasErrors = true;
        }
    }
    // Verify name
    if (!exports.validatePackageJsonName(root, { pkgJson, name })) {
        if (fix) {
            hasErrors = !exports.updatePackageJsonName(root, { name });
        }
        else {
            hasErrors = true;
        }
    }
    if (!hasErrors) {
        logging_1.log('VALIDATE', `Package ${logging_1.yellowBright(pkgJson.name)} is valid.`);
    }
    return !hasErrors;
};
exports.runNpmPublish = ({ dryRun, pkgFiles, version, tag, local, localUrl, }) => {
    const registryUrl = local ? localUrl : 'https://registry.npmjs.org/';
    let hasErrors = false;
    for (const pkgFile of pkgFiles) {
        const filePath = path_1.relative(process.cwd(), pkgFile);
        // Skip the root package.json file
        if (filePath !== 'package.json') {
            const baseDir = path_1.dirname(filePath);
            const pkgInfo = fs_extra_1.readJSONSync(path_1.join(process.cwd(), pkgFile));
            const name = `${pkgInfo.name}@${version}`;
            const command = `npm publish --tag ${tag} --access public --registry=${registryUrl}`;
            if (!dryRun) {
                try {
                    exports.exec(command, { cwd: baseDir });
                }
                catch (e) {
                    logging_1.error(`Failed to publish ${name} to npm:`);
                    console.log(e);
                    hasErrors = true;
                }
            }
            else {
                logging_1.log(`[dry-run]`, 'Skipping command', logging_1.gray(command));
            }
        }
    }
    return !hasErrors;
};
exports.runReleaseIt = ({ ci = false, dryRun = false, preRelease, version, }) => {
    const options = {
        ci,
        'dry-run': dryRun,
        changelogCommand: 'conventional-changelog -p angular | tail -n +3',
        /**
         * Needed so that we can leverage conventional-changelog to generate
         * the changelog
         */
        safeBump: false,
        /**
         * All the package.json files that will have their version updated
         * by release-it
         */
        increment: version,
        requireUpstream: false,
        github: {
            preRelease: preRelease,
            release: true,
            token: process.env.GITHUB_TOKEN,
        },
        npm: {
            /**
             * We don't use release-it to do the npm publish, because it is not
             * able to understand our multi-package setup.
             */
            release: false,
            publish: false,
        },
        git: {
            requireCleanWorkingDir: false,
        },
    };
    return releaseIt(options)
        .then(() => {
        return true;
    })
        .catch((err) => {
        logging_1.error(err.message);
        return false;
    });
};
exports.selectFromList = async (choices, { addBack = false, addExit = false, message, }) => {
    const options = [...choices];
    const extraOptions = [];
    if (addBack) {
        extraOptions.push(projects_1.BACK_OPTION);
    }
    if (addExit) {
        extraOptions.push(projects_1.EXIT_OPTION);
    }
    const response = await inquirer.prompt([
        {
            name: 'select',
            type: 'list',
            message,
            choices: extraOptions.length === 0
                ? [...options]
                : [...options, new inquirer.Separator(), ...extraOptions, new inquirer.Separator()],
        },
    ]);
    if (response.select === projects_1.EXIT_OPTION) {
        console.clear();
        return false;
    }
    return response.select;
};
async function fetchJson(url) {
    return node_fetch_1.default(url).then((data) => data.json());
}
exports.fetchJson = fetchJson;
async function cacheUrls(urls, cachePath) {
    fs_extra_1.mkdirpSync(path_1.dirname(cachePath));
    const results = await Promise.all(urls.map(fetchJson));
    const cache = urls.reduce((acc, curr, i) => (Object.assign(Object.assign({}, acc), { [curr]: results[i] })), {});
    fs_extra_1.writeJSONSync(cachePath, cache, { spaces: 2 });
}
exports.cacheUrls = cacheUrls;
